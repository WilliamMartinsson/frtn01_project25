import se.lth.control.DoublePoint;
import se.lth.control.realtime.IOChannelException;
import se.lth.control.realtime.Semaphore;

public class Regul extends Thread {
	public static final int OFF = 0;
	public static final int BEAM = 1;
	public static final int BALL = 2;

	private PI inner = new PI("PI");
	private PID outer = new PID("PID");

	private IO analogInAngle;
	private IO analogInPosition;
	private IO analogOut;

	private ReferenceGeneratorProxy referenceGenerator;
	private OpComProxy opcom;

	private int priority;
	private boolean WeShouldRun = true;
	private long starttime;
	private Semaphore mutex; // used for synchronization at shut-down

	private ModeMonitor modeMon;

	// Inner monitor class
	class ModeMonitor {
		private int mode;

		// Synchronized access methods
		public synchronized void setMode(int newMode) {
			mode = newMode;
		}

		public synchronized int getMode() {
			return mode;
		}
	}

	public Regul(int pri) {
		priority = pri;
		mutex = new Semaphore(1);
		try {
			analogInAngle = IO.getIO(0);
			//analogInAngle = new AnalogIn(0);
			analogInPosition = IO.getIO(1);
			//analogInPosition = new AnalogIn(1);
			analogOut = IO.getIO(2);
			//analogOut = new AnalogOut(0);
		} catch (IOChannelException e) {
			System.out.print("Error: IOChannelException: ");
			System.out.println(e.getMessage());
		}
		modeMon = new ModeMonitor();
	}

	public void setOpCom(OpComProxy opcom) {
        this.opcom = opcom;
	}

	public void setRefGen(ReferenceGeneratorProxy referenceGenerator){
        this.referenceGenerator = referenceGenerator;
	}

	// Called in every sample in order to send plot data to OpCom
	private void sendDataToOpCom(double yref, double y, double u) {
		double x = (double)(System.currentTimeMillis() - starttime) / 1000.0;
		DoublePoint dp = new DoublePoint(x, u);
		PlotData pd = new PlotData(x, yref, y);
		opcom.putControlDataPoint(dp);
		opcom.putMeasurementDataPoint(pd);
	}

	public synchronized void setInnerParameters(PIParameters p) {
		inner.setParameters(p);
	}

	public synchronized PIParameters getInnerParameters() {
		return inner.getParameters();
	}

	public synchronized void setOuterParameters(PIDParameters p) {
		outer.setParameters(p);
	}

	public synchronized PIDParameters getOuterParameters(){
		return outer.getParameters();
	}

	public void setOFFMode(){
        modeMon.setMode(OFF);

	}

	public void setBEAMMode(){
        modeMon.setMode(BEAM);

	}

	public void setBALLMode(){
        modeMon.setMode(BALL);
	}

	public int getMode(){
        return modeMon.getMode();
	}

	// Called from OpCom when shutting down
	public synchronized void shutDown() {
		WeShouldRun = false;
		mutex.take();
		try {
			analogOut.setValue(0);
		} catch (IOChannelException x) {
		}
	}

	private double limit(double v, double min, double max) {
		if (v < min) {
			v = min;
		} else {
			if (v > max) {
				v = max;
			}
		}
		return v;
	}

	public void run() {
		long duration;
		long t = System.currentTimeMillis();
		starttime = t;

		this.setPriority(priority);
		mutex.take();
		while (WeShouldRun) {
			switch (modeMon.getMode()) {
			case OFF: {
                inner.reset();
                outer.reset();
                this.sendDataToOpCom(0, 0, 0);
                try {
                    analogOut.set(0);
                } catch (Exception e) {
                    System.out.println("Failed to write to analog output");
                }
                break;
			}
			case BEAM: {
                double yref = referenceGenerator.getRef();
                double yAnalog = 0;
                try {
                    yAnalog = analogInAngle.get();
                } catch (Exception e){
                    System.out.println("Failed to get angle value");
                }
                double u = limit(inner.calculateOutput(yAnalog, yref), -10, 10);
                this.sendDataToOpCom(yref, yAnalog, u);
                inner.updateState(u);
                try {
                    analogOut.set(u);
                }catch (Exception e) {
                    System.out.println("Failed to write to analog output");
                }
				break;
			}
			case BALL: {
                double angle = 0;
                double position = 0;
                try {
                    angle = analogInAngle.get();
                    position = analogInPosition.get();
                } catch (Exception e) {
                    System.out.println("Failed to get analog output: angle or position");
                }
                double ref = referenceGenerator.getRef();
                double uOuter = limit(outer.calculateOutput(position, ref),-10,10);
                double u = limit(inner.calculateOutput(angle, uOuter), -10, 10);
                try {
                    analogOut.set(u);
                } catch (Exception e) {
                    System.out.println("Failed to write to analog output");
                }
               
                outer.updateState(uOuter);
                inner.updateState(u);
                System.out.println("Styr:" + u);
                this.sendDataToOpCom(ref, position, u);
				break;
			}
			default: {
				System.out.println("Error: Illegal mode.");
				break;
			}
			}
			// sleep
			t = t + inner.getHMillis();
			duration = t - System.currentTimeMillis();
			if (duration > 0) {
				try {
					sleep(duration);
				} catch (InterruptedException x) {}
			}
		}
		mutex.give();
	}
}